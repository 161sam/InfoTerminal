// Enhanced dossier export utilities for analytics
import { AnalyticsDossierExport, AnalyticsDossierSection } from "@/components/analytics/types";

export interface DossierExportOptions {
  format: "markdown" | "pdf" | "html";
  includeMetadata: boolean;
  includeCharts: boolean;
  template?: "standard" | "executive" | "technical";
}

export interface ExportResult {
  success: boolean;
  downloadUrl?: string;
  error?: string;
  metadata: {
    fileSize: number;
    generatedAt: string;
    format: string;
  };
}

export class AnalyticsDossierExporter {
  private apiBaseUrl: string;

  constructor(apiBaseUrl: string = "/api/dossier") {
    this.apiBaseUrl = apiBaseUrl;
  }

  async exportDossier(
    dossier: AnalyticsDossierExport,
    options: DossierExportOptions,
  ): Promise<ExportResult> {
    try {
      const payload = {
        ...dossier,
        options,
        exportId: this.generateExportId(),
      };

      const response = await fetch(`${this.apiBaseUrl}/analytics/export`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Export failed: ${response.statusText}`);
      }

      const result = await response.json();
      return result;
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown export error",
        metadata: {
          fileSize: 0,
          generatedAt: new Date().toISOString(),
          format: options.format,
        },
      };
    }
  }

  async exportToMarkdown(dossier: AnalyticsDossierExport): Promise<string> {
    let content = this.generateMarkdownHeader(dossier);

    // Table of Contents
    content += this.generateTableOfContents(dossier.sections);

    // Executive Summary
    content += this.generateExecutiveSummary(dossier);

    // Filter Summary
    content += this.generateFilterSummary(dossier);

    // Sections
    for (const section of dossier.sections) {
      content += this.generateSectionContent(section);
    }

    // Appendix
    content += this.generateAppendix(dossier);

    return content;
  }

  async exportClientSide(
    dossier: AnalyticsDossierExport,
    options: DossierExportOptions,
  ): Promise<void> {
    let content: string;
    let mimeType: string;
    let fileExtension: string;

    switch (options.format) {
      case "markdown":
        content = await this.exportToMarkdown(dossier);
        mimeType = "text/markdown";
        fileExtension = "md";
        break;
      case "html":
        content = await this.exportToHtml(dossier);
        mimeType = "text/html";
        fileExtension = "html";
        break;
      default:
        throw new Error("PDF export requires server-side processing");
    }

    this.downloadFile(content, dossier.title, fileExtension, mimeType);
  }

  private generateMarkdownHeader(dossier: AnalyticsDossierExport): string {
    let header = `# ${dossier.title}\n\n`;

    if (dossier.description) {
      header += `*${dossier.description}*\n\n`;
    }

    header += `---\n\n`;
    header += `**Generated:** ${new Date(dossier.metadata.generatedAt).toLocaleString()}  \n`;
    header += `**Generated By:** ${dossier.metadata.generatedBy}  \n`;
    header += `**Version:** ${dossier.metadata.version}  \n`;
    header += `**Time Range:** ${dossier.filters.timeRange}  \n\n`;

    return header;
  }

  private generateTableOfContents(sections: AnalyticsDossierSection[]): string {
    let toc = `## Table of Contents\n\n`;
    toc += `1. [Executive Summary](#executive-summary)\n`;
    toc += `2. [Filter Configuration](#filter-configuration)\n`;

    sections.forEach((section: AnalyticsDossierSection, index: number) => {
      const anchor = section.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
      toc += `${index + 3}. [${section.name}](#${anchor})\n`;
    });

    toc += `${sections.length + 3}. [Appendix](#appendix)\n\n`;
    return toc;
  }

  private generateExecutiveSummary(dossier: AnalyticsDossierExport): string {
    let summary = `## Executive Summary\n\n`;

    summary += `This analytics report covers the period of **${dossier.filters.timeRange}** `;
    summary += `and includes analysis across ${dossier.sections.length} key areas:\n\n`;

    dossier.sections.forEach((section: AnalyticsDossierSection) => {
      summary += `- **${section.name}:** ${section.description}\n`;
    });

    summary += `\n`;

    // Key findings based on available data
    if (dossier.sections.some((s: AnalyticsDossierSection) => s.id === "entity-analytics" && s.data)) {
      const entityData = dossier.sections.find((s: AnalyticsDossierSection) => s.id === "entity-analytics")?.data;
      if (entityData?.totalEntities) {
        summary += `### Key Findings\n\n`;
        summary += `- **${entityData.totalEntities.toLocaleString()}** total entities identified\n`;
        if (entityData.newEntities > 0) {
          summary += `- **${entityData.newEntities.toLocaleString()}** new entities discovered\n`;
        }
        summary += `\n`;
      }
    }

    return summary;
  }

  private generateFilterSummary(dossier: AnalyticsDossierExport): string {
    let summary = `## Filter Configuration\n\n`;

    summary += `The following filters were applied to generate this report:\n\n`;
    summary += `| Filter | Value |\n`;
    summary += `|--------|-------|\n`;
    summary += `| Time Range | ${dossier.filters.timeRange} |\n`;

    if (dossier.filters.entityTypes.length > 0) {
      summary += `| Entity Types | ${dossier.filters.entityTypes.join(", ")} |\n`;
    }

    if (dossier.filters.sources.length > 0) {
      summary += `| Sources | ${dossier.filters.sources.join(", ")} |\n`;
    }

    if (dossier.filters.tags.length > 0) {
      summary += `| Tags | ${dossier.filters.tags.join(", ")} |\n`;
    }

    if (dossier.filters.dateRange) {
      summary += `| Custom Date Range | ${dossier.filters.dateRange.from} to ${dossier.filters.dateRange.to} |\n`;
    }

    summary += `\n`;
    return summary;
  }

  private generateSectionContent(section: AnalyticsDossierSection): string {
    const anchor = section.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    let content = `## ${section.name} {#${anchor}}\n\n`;

    content += `${section.description}\n\n`;

    if (section.data) {
      content += this.formatSectionData(section.id, section.data);
    } else {
      content += `*No data available for the selected filters and time period.*\n\n`;
    }

    return content;
  }

  private formatSectionData(sectionId: string, data: any): string {
    switch (sectionId) {
      case "entity-analytics":
        return this.formatEntityAnalytics(data);
      case "source-coverage":
        return this.formatSourceCoverage(data);
      case "evidence-quality":
        return this.formatEvidenceQuality(data);
      case "workflow-runs":
        return this.formatWorkflowRuns(data);
      default:
        return `*Data visualization would be included here in the final export.*\n\n`;
    }
  }

  private formatEntityAnalytics(data: any): string {
    let content = `### Summary Statistics\n\n`;
    content += `- **Total Entities:** ${data.totalEntities?.toLocaleString() || 0}\n`;
    content += `- **New Entities:** ${data.newEntities?.toLocaleString() || 0}\n`;
    content += `- **Entity Types:** ${data.entityTypes?.length || 0}\n`;
    content += `- **Relationship Density:** ${data.relationshipDensity?.toFixed(2) || 0}\n\n`;

    if (data.topEntities && data.topEntities.length > 0) {
      content += `### Top Entities\n\n`;
      content += `| Entity | Type | Mentions | Confidence |\n`;
      content += `|--------|------|----------|------------|\n`;
      data.topEntities.slice(0, 10).forEach((entity: any) => {
        content += `| ${entity.name} | ${entity.type} | ${entity.mentions} | ${Math.round(entity.confidence * 100)}% |\n`;
      });
      content += `\n`;
    }

    return content;
  }

  private formatSourceCoverage(data: any): string {
    let content = `### Coverage Overview\n\n`;
    content += `- **Total Sources:** ${data.totalSources?.toLocaleString() || 0}\n`;
    content += `- **Active Sources:** ${data.activeSources?.toLocaleString() || 0}\n`;
    content += `- **Source Types:** ${data.sourceTypes?.length || 0}\n\n`;

    if (data.topSources && data.topSources.length > 0) {
      content += `### Top Sources\n\n`;
      content += `| Source | Type | Documents | Reliability |\n`;
      content += `|--------|------|-----------|-------------|\n`;
      data.topSources.slice(0, 10).forEach((source: any) => {
        content += `| ${source.name} | ${source.type} | ${source.documents} | ${Math.round(source.reliability * 100)}% |\n`;
      });
      content += `\n`;
    }

    return content;
  }

  private formatEvidenceQuality(data: any): string {
    let content = `### Quality Assessment\n\n`;
    content += `- **Overall Score:** ${data.overallScore || 0}/100\n`;
    content += `- **Total Claims:** ${data.totalClaims?.toLocaleString() || 0}\n`;
    content += `- **Verified Claims:** ${data.verifiedClaims?.toLocaleString() || 0}\n`;

    if (data.totalClaims > 0) {
      const verificationRate = Math.round((data.verifiedClaims / data.totalClaims) * 100);
      content += `- **Verification Rate:** ${verificationRate}%\n`;
    }

    content += `\n`;

    return content;
  }

  private formatWorkflowRuns(data: any): string {
    if (!Array.isArray(data) || data.length === 0) {
      return `*No workflow runs found for the selected period.*\n\n`;
    }

    let content = `### Execution Summary\n\n`;
    content += `- **Total Runs:** ${data.length}\n`;

    const completed = data.filter((run) => run.status === "completed").length;
    const failed = data.filter((run) => run.status === "failed").length;
    const running = data.filter((run) => run.status === "running").length;

    content += `- **Completed:** ${completed}\n`;
    content += `- **Failed:** ${failed}\n`;
    content += `- **Running:** ${running}\n`;
    content += `- **Success Rate:** ${Math.round((completed / data.length) * 100)}%\n\n`;

    return content;
  }

  private generateAppendix(dossier: AnalyticsDossierExport): string {
    let appendix = `## Appendix\n\n`;

    appendix += `### Technical Details\n\n`;
    appendix += `- **Report Generated:** ${new Date(dossier.metadata.generatedAt).toISOString()}\n`;
    appendix += `- **System Version:** ${dossier.metadata.version}\n`;
    appendix += `- **Export Format:** Markdown\n`;
    appendix += `- **Sections Included:** ${dossier.sections.length}\n\n`;

    appendix += `### Filter Snapshot\n\n`;
    appendix += `\`\`\`json\n`;
    appendix += JSON.stringify(dossier.filters, null, 2);
    appendix += `\n\`\`\`\n\n`;

    return appendix;
  }

  private async exportToHtml(dossier: AnalyticsDossierExport): Promise<string> {
    const markdown = await this.exportToMarkdown(dossier);

    // Basic Markdown to HTML conversion
    let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${dossier.title}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 800px; margin: 0 auto; padding: 2rem; }
        h1 { color: #1f2937; border-bottom: 2px solid #e5e7eb; padding-bottom: 0.5rem; }
        h2 { color: #374151; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.25rem; margin-top: 2rem; }
        table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
        th, td { border: 1px solid #d1d5db; padding: 0.5rem; text-align: left; }
        th { background-color: #f9fafb; font-weight: 600; }
        code { background-color: #f3f4f6; padding: 0.25rem 0.5rem; border-radius: 0.25rem; }
        pre { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
    </style>
</head>
<body>`;

    // Simple markdown to HTML conversion
    html += markdown
      .replace(/^# (.*$)/gm, "<h1>$1</h1>")
      .replace(/^## (.*$)/gm, "<h2>$1</h2>")
      .replace(/^### (.*$)/gm, "<h3>$1</h3>")
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      .replace(/\*(.*?)\*/g, "<em>$1</em>")
      .replace(/`([^`]+)`/g, "<code>$1</code>")
      .replace(/\n\n/g, "</p><p>")
      .replace(/^([^<])/gm, "<p>$1")
      .replace(/([^>])$/gm, "$1</p>");

    html += `</body></html>`;

    return html;
  }

  private downloadFile(content: string, title: string, extension: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${title.replace(/[^a-z0-9]/gi, "_")}.${extension}`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  private generateExportId(): string {
    return `analytics_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}

export const analyticsDossierExporter = new AnalyticsDossierExporter();
