apiVersion: v1
kind: ConfigMap
metadata:
  name: authz-proxy-app
  namespace: policy
data:
  app.py: |
    import os, json
    from fastapi import FastAPI, Request, Response
    import httpx
    from jose import jwt
    from cachetools import TTLCache

    ISSUER = os.getenv("KEYCLOAK_ISSUER","http://localhost:8081/realms/infoterminal")
    AUD = os.getenv("KEYCLOAK_AUDIENCE","search-api")
    JWKS_URL = f"{ISSUER}/protocol/openid-connect/certs"
    OPA_URL = os.getenv("OPA_URL","http://opa.policy.svc.cluster.local:8181/v1/data/access/allow")
    _cache = TTLCache(1, 300)

    def _jwks():
        if "jwks" in _cache: return _cache["jwks"]
        d = httpx.get(JWKS_URL, timeout=5).json(); _cache["jwks"]=d; return d

    def _user_from_authz(hv:str|None):
        if not hv or not hv.startswith("Bearer "): return None
        token = hv.split(" ",1)[1]
        claims = jwt.decode(token, _jwks(), algorithms=["RS256"], audience=AUD, issuer=ISSUER)
        roles = claims.get("roles") or claims.get("realm_access",{}).get("roles",[])
        return {"sub":claims.get("sub"), "roles":roles, "username":claims.get("preferred_username")}

    app = FastAPI()

    @app.get("/health") 
    def health(): return {"ok": True}

    @app.get("/authz")
    async def authz(request: Request):
        # allow unauthenticated pass-through (App kann OIDC selbst machen)
        auth = request.headers.get("authorization")
        user = None
        if auth:
            try:
                user = _user_from_authz(auth)
            except Exception:
                # kein valider Token -> 401
                return Response(status_code=401)

        # Beispiel-Resource: aus Host/Path grob ableiten
        host = request.headers.get("x-forwarded-host","")
        resource = {"classification":"public","host":host}
        inp = {"input":{"user": user or {"roles":["anonymous"]}, "action":"read", "resource": resource}}
        try:
            r = httpx.post(OPA_URL, json=inp, timeout=3); r.raise_for_status()
            allow = bool(r.json().get("result", False))
        except Exception:
            allow = True  # dev fail-open

        if allow:
            headers = {}
            if user:
                headers["X-User"] = user.get("username") or user.get("sub","")
                headers["X-Roles"] = ",".join(user.get("roles",[]))
            return Response(status_code=200, headers=headers)
        return Response(status_code=403)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: authz-proxy
  namespace: policy
spec:
  replicas: 1
  selector: { matchLabels: { app: authz-proxy } }
  template:
    metadata: { labels: { app: authz-proxy } }
    spec:
      containers:
      - name: app
        image: python:3.11-slim
        command: ["/bin/sh","-c"]
        args:
          - pip install -q fastapi uvicorn httpx python-jose[cryptography] cachetools &&
            uvicorn app:app --host 0.0.0.0 --port 8080
        ports: [ { containerPort: 8080 } ]
        env:
          - { name: KEYCLOAK_ISSUER, value: "http://localhost:8081/realms/infoterminal" }
          - { name: KEYCLOAK_AUDIENCE, value: "search-api" }
          - { name: OPA_URL, value: "http://opa.policy.svc.cluster.local:8181/v1/data/access/allow" }
        volumeMounts:
          - name: app
            mountPath: /app
      volumes:
        - name: app
          configMap: { name: authz-proxy-app }
---
apiVersion: v1
kind: Service
metadata:
  name: authz-proxy
  namespace: policy
spec:
  selector: { app: authz-proxy }
  ports:
    - name: http
      port: 80
      targetPort: 8080
