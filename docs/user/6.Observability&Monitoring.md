# 6. Observability & Monitoring

Transparenz gehört zur Grundarchitektur von InfoTerminal. Jedes v1-Service bringt Health-/Ready-Checks, strukturierte Logs und optionale Telemetrie mit.

---

## 6.1 Stack-Überblick

```
Services → OTEL Instrumentation → Prometheus & Tempo → Grafana & Alertmanager → Dashboards/Alerts
```

| Dienst | Port (Host) | Funktion |
| ------ | ----------- | -------- |
| Prometheus | 3412 | Metriksammlung (`/metrics`) |
| Grafana | 3413 | Dashboards & Ad-hoc-Abfragen |
| Alertmanager | 3414 | Alerting & Routing |
| Loki | 3415 | Zentrales Log-Backend (JSON Lines) |
| Tempo | 3416 | Distributed Tracing |

Aktivierung:
```bash
it start --profile observability
# oder
docker compose -f docker-compose.observability.yml --profile observability up -d
```

Alle Komponenten sind optional und verbrauchen nur Ressourcen, wenn sie gestartet werden.

---

## 6.2 Service-Metriken

- Metriken liegen auf `http://<service>/metrics` (Prometheus-Format). 
- Aktivierung per `IT_ENABLE_METRICS=1` (default: aus). Bei `scripts/dev_up.sh` im Dev-Modus bleiben Metriken deaktiviert.
- Beispiele:
  - `search_requests_total`, `search_rerank_latency_seconds_bucket`
  - `graph_api_requests_total`, `graph_api_algorithm_duration_seconds`
  - `doc_entities_requests_total`, `doc_entities_summary_latency_ms`
- Prometheus-Scrape-Config liegt unter `observability/prometheus/prometheus.yml`.

---

## 6.3 Logs & Traces

- **Strukturierte Logs** (JSON) werden via Loki gesammelt. Services verwenden `RequestIdMiddleware`, sodass `X-Request-Id` logübergreifend gesucht werden kann.
- **Tempo** speichert OTEL-Traces. Aktivieren via `IT_OTEL=1` oder Service-spezifisch `OTEL_EXPORTER_OTLP_ENDPOINT=http://tempo:4317`.
- **CLI-Hilfe**: `it logs --services search-api --format jsonl --lines 100` liest Logs direkt über Docker.
- **Best Practice**: Metriken & Logs nur für produktive Umgebungen aktivieren; in Dev-Umgebungen Telemetriedaten über `OTEL_SDK_DISABLED=1` unterdrücken.

---

## 6.4 Dashboards

- **Grafana** ist vorprovisioniert (Login: `admin / admin`). Ordner *InfoTerminal* enthält:
  - API Overview (Statuscodes, Latenzen, Requests)
  - Doc-Entities (Durchsatz, Queue-Status, Fehlerraten)
  - Graph Metrics (Cypher-Auslastung, Neo4j-Verbindungen)
  - Infrastructure (Docker CPU/Mem via Node Exporter, optional)
- **Log-Queries**: In Grafana->Loki, z. B. `{service="graph-api"} | json | line_format "{{.message}}"`.
- **Trace-Ansicht**: Grafana/Tempo „Traces“ → Filter nach `service.name`.

---

## 6.5 Alerts & Runbooks

- Alertmanager-Konfiguration (`observability/alertmanager.yml`) definiert Beispielregeln (z. B. *Search API Down*, *High Error Rate*).
- Runbooks liegen in `docs/dev/runbooks/`. Enthalten: Fehlerklassen, Eskalationswege, CLI-Kommandos.
- Ops-Controller kann Alerts konsumieren und automatisiert Gegenmaßnahmen starten (z. B. `it restart --services search-api`).

---

## 6.6 Health & Diagnostics

- **Health Widgets**: Das Frontend zeigt Live-Status in Kopfzeile und Seiten-spezifischen Panels.
- **CLI**: `it status --format json` liefert Compose-Status + Health-Probes.
- **APIs**: `GET /healthz` (leichtgewichtig), `GET /readyz` (inkl. abhängiger Systeme). `IT_FORCE_READY=1` setzt Ready-Status für Tests.
- **Tracing Debug**: Mit `IT_TRACE_QUERIES=1` (Graph API) werden Cypher-Statements in Logs geschrieben.

---

## 6.7 Best Practices

- Observability-Profile nur aktivieren, wenn Monitoring benötigt wird – spart RAM/CPU.
- Alerts definieren, bevor produktive Daten verarbeitet werden (mindestens „Service down“ und „Error rate > 5 %“).
- Log-Reduktion: In produktiven Umgebungen `LOG_LEVEL=INFO` setzen; Debug nur temporär.
- Tracing gezielt aktivieren (Performance-Analysen, Fehlerreproduktion), danach wieder deaktivieren.

Weitere Detailinformationen stehen in `docs/dev/observability.md` und den Runbooks.
