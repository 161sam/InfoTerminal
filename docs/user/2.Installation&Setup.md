# 2. Installation & Setup

## 2.1 Systemvoraussetzungen

| Komponente | Empfehlung |
| ---------- | ---------- |
| Betriebssystem | Linux (Ubuntu 22.04/24.04), macOS 13+, Windows 11 (WSL2 empfohlen) |
| CPU | ≥ 4 Kerne (x86_64 oder ARM64) |
| RAM | ≥ 16 GB (12 GB Minimum für Demo-Stack) |
| Speicherplatz | 15 GB für Container + Daten (OpenSearch, Neo4j, Postgres) |
| Pflichtsoftware | Docker & Docker Compose, Python 3.10+, Node.js 20+, pnpm 8+, `pipx`, `make` |

Für Tests ohne Container werden zusätzlich `neo4j`, `opensearch` und `postgres` lokal benötigt – standardmäßig werden sie jedoch via Docker bereitgestellt.

## 2.2 Repository & Grundkonfiguration

```bash
# Repository klonen
git clone https://github.com/161sam/InfoTerminal.git
cd InfoTerminal

# Basis-ENV für Compose und Frontend ableiten
cp .env.example .env
cp apps/frontend/.env.example apps/frontend/.env.local
```

`patch_ports.sh` stellt sicher, dass alle Host-Ports nicht mit Standards kollidieren. Bei Konflikten ausführen:

```bash
scripts/patch_ports.sh
```

## 2.3 CLI installieren (empfohlener Einstieg)

Die **InfoTerminal CLI** (`it`) wird lokal aus dem Repository installiert:

```bash
pipx install --force ./cli
it --version
```

`pipx install --force` aktualisiert die CLI bei späteren Pulls. Konfiguration (z. B. alternative Service-URLs) wird unter `~/.config/infoterminal/config.json` abgelegt und kann manuell angepasst werden.

## 2.4 Startoptionen

### Option A – Komplett via CLI (Docker Compose)

```bash
# Alle Kernservices + Frontend starten
it start -f docker-compose.yml

# Status prüfen
it status --format table

# Frontend unter http://localhost:3411 aufrufen
```

Die CLI kapselt die Compose-Parameter; `--services` erlaubt das Auswählen einzelner Services, `--profile` aktiviert Zusatzprofile (z. B. `observability`).

Beenden der Umgebung:

```bash
it stop
# optional: Volumes & Images entfernen
it rm -v --images local
```

### Option B – Lokaler Dev-Modus (`scripts/dev_up.sh`)

Der Dev-Modus startet die APIs mit `uvicorn` (Hot-Reload) und das Frontend im Next.js-Dev-Server.

```bash
# Container-Infrastruktur (OpenSearch, Neo4j, Postgres) + lokale APIs
dev_up.sh            # Alias: scripts/dev_up.sh

# Lokale Services statt Container
DEV_LOCAL=1 OBS=0 AGENTS=0 scripts/dev_up.sh
```

Flags:
- `OBS=1` startet Prometheus/Grafana/Loki/Tempo.
- `AGENTS=1` startet den Flowise-Connector (Port 3417).
- `GW=1` aktiviert Gateway + OPA.

Logs werden nach `/tmp/it_<service>.log` geschrieben und über `tail -f /tmp/it_*.log` verfolgt.

## 2.5 Optionalprofile & Zusatzdienste

| Profil | Aktivierung | Enthalten |
| ------ | ----------- | --------- |
| Observability | `it start --profile observability` oder `OBS=1` | Prometheus (3412), Grafana (3413), Alertmanager (3414), Loki (3415), Tempo (3416) |
| Agents | `AGENTS=1` oder `it start -f docker-compose.agents.yml --profile agents` | Flowise-Connector (3417) |
| Gateway | `GW=1` oder `it start -f docker-compose.gateway.yml` | API-Gateway auf 8610 mit Rate-Limiting & OTEL |
| NLP | `docker compose -f docker-compose.nlp.yml up -d doc-entities` | Doc-Entities-Service (8613) für NLP-Annotation |
| Auth/OIDC | `docker compose -f docker-compose.sso.yml up -d` | Keycloak-Demo-Setup + OAuth-Flow |

## 2.6 Ports & Umgebungsvariablen

- Kernports: Frontend 3411, Search API 8401 (Docker: 8611), Graph API 8402 (Docker: 8612), Graph-Views 8403 (via Gateway), Doc-Entities 8406 (Docker: 8613).
- Observability-Ports siehe Kapitel 6 bzw. `docker-compose.observability.yml`.
- Alle Zuordnungen leben in `.env.dev.ports` und werden von `scripts/patch_ports.sh` gepflegt.

Wichtige Variablen (siehe auch Anhang):
- `NEXT_PUBLIC_*` steuern Frontend-Endpunkte & Feature-Flags.
- `IT_ENABLE_METRICS`, `IT_OTEL` aktivieren Metriken/Tracing pro Service.
- `DEV_LOCAL=1` erzwingt lokale Starts in `dev_up.sh`.

## 2.7 Health-Checks & Smoke-Tests

| Service | Health | Ready |
| ------- | ------ | ----- |
| Search API | `curl http://localhost:8401/healthz` | `/readyz` prüft OpenSearch |
| Graph API | `curl http://localhost:8402/healthz` | `/readyz` mit Neo4j-Ping |
| Graph-Views | `curl http://localhost:8403/healthz` | `/readyz` prüft Neo4j + Graph API |
| Doc-Entities | `curl http://localhost:8406/healthz` | `/readyz` prüft Postgres | 

Zusätzlich bietet das Frontend eine Health-Kachel in der Kopfzeile. Die CLI spiegelt dieselben Checks über `it status` wider.

## 2.8 Troubleshooting

- **Docker-Ports blockiert** → `scripts/patch_ports.sh` ausführen oder Prozesse über `lsof -i :<PORT>` beenden.
- **Frontend-Build schlägt fehl** → Node.js ≥ 20 & pnpm ≥ 8 erforderlich (`corepack enable`).
- **Neo4j Auth-Fehler** → Standard im Dev: `neo4j` / `test12345`; Volumen ggf. leeren (`docker volume rm infoterminal_neo4j_data`).
- **CLI findet Services nicht** → `~/.config/infoterminal/config.json` prüfen oder `IT_SEARCH_API` etc. als Umgebungsvariablen setzen.
- **Langsame Suche** → Reranking deaktivieren (`RERANK_ENABLED=0`) oder `RERANK_TOPK` reduzieren.
- **Doc-Entities ohne GPU** → Service läuft CPU-only; bei großen Dokumenten `ALLOW_TEST=1` für leichtere Verarbeitung aktivieren.
- **SSL/Proxy** → Gateway mit `USE_LOCAL_UPSTREAMS=1` starten oder direkt auf Services gehen (vgl. Kapitel 6/9).
